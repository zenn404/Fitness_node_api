{"mappings":"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","sources":["packages/@react-stately/dnd/src/useDroppableCollectionState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DragTypes, DropOperation, DroppableCollectionProps, DropTarget, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCallback, useRef, useState} from 'react';\n\ninterface DropOperationEvent {\n  target: DropTarget,\n  types: DragTypes,\n  allowedOperations: DropOperation[],\n  isInternal: boolean,\n  draggingKeys: Set<Key>\n}\n\nexport interface DroppableCollectionStateOptions extends Omit<DroppableCollectionProps, 'onDropMove' | 'onDropActivate'> {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** Whether the drop events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface DroppableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The current drop target. */\n  target: DropTarget | null,\n  /** Whether drop events are disabled. */\n  isDisabled?: boolean,\n  /** Sets the current drop target. */\n  setTarget(target: DropTarget | null): void,\n  /** Returns whether the given target is equivalent to the current drop target. */\n  isDropTarget(target: DropTarget | null): boolean,\n  /** Returns the drop operation for the given parameters. */\n  getDropOperation(e: DropOperationEvent): DropOperation\n}\n\n/**\n * Manages state for a droppable collection.\n */\nexport function useDroppableCollectionState(props: DroppableCollectionStateOptions): DroppableCollectionState  {\n  let {\n    acceptedDragTypes = 'all',\n    isDisabled,\n    onInsert,\n    onRootDrop,\n    onItemDrop,\n    onReorder,\n    onMove,\n    shouldAcceptItemDrop,\n    collection,\n    selectionManager,\n    onDropEnter,\n    getDropOperation,\n    onDrop\n  } = props;\n  let [target, setTarget] = useState<DropTarget | null>(null);\n  let targetRef = useRef<DropTarget | null>(null);\n\n  let getOppositeTarget = (target: ItemDropTarget): ItemDropTarget | null => {\n    if (target.dropPosition === 'before') {\n      let node = collection.getItem(target.key);\n      return node && node.prevKey != null\n        ? {type: 'item', key: node.prevKey, dropPosition: 'after'} \n        : null;\n    } else if (target.dropPosition === 'after') {\n      let node = collection.getItem(target.key);\n      return node && node.nextKey != null\n        ? {type: 'item', key: node.nextKey, dropPosition: 'before'} \n        : null;\n    }\n    return null;\n  };\n\n  let defaultGetDropOperation = useCallback((e: DropOperationEvent) => {\n    let {\n      target,\n      types,\n      allowedOperations,\n      isInternal,\n      draggingKeys\n    } = e;\n\n    if (isDisabled || !target) {\n      return 'cancel';\n    }\n\n    if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => types.has(type))) {\n      let isValidInsert = onInsert && target.type === 'item' && !isInternal && (target.dropPosition === 'before' || target.dropPosition === 'after');\n      let isValidReorder = onReorder\n        && target.type === 'item'\n        && isInternal\n        && (target.dropPosition === 'before' || target.dropPosition === 'after')\n        && isDraggingWithinParent(collection, target, draggingKeys);\n\n      let isItemDropAllowed = target.type !== 'item'\n        || target.dropPosition !== 'on'\n        || (!shouldAcceptItemDrop || shouldAcceptItemDrop(target, types));\n\n      let isValidMove = onMove\n        && target.type === 'item'\n        && isInternal\n        && isItemDropAllowed;\n\n      // Feedback was that internal root drop was weird so preventing that from happening\n      let isValidRootDrop = onRootDrop && target.type === 'root' && !isInternal;\n      \n      // Automatically prevent items (i.e. folders) from being dropped on themselves.\n      let isValidOnItemDrop = onItemDrop \n        && target.type === 'item' \n        && target.dropPosition === 'on' \n        && !(isInternal && target.key != null && draggingKeys.has(target.key)) \n        && isItemDropAllowed;\n\n      if (onDrop || isValidInsert || isValidReorder || isValidMove || isValidRootDrop || isValidOnItemDrop) {\n        if (getDropOperation) {\n          return getDropOperation(target, types, allowedOperations);\n        } else {\n          return allowedOperations[0];\n        }\n      }\n    }\n\n    return 'cancel';\n  }, [isDisabled, collection, acceptedDragTypes, getDropOperation, onInsert, onRootDrop, onItemDrop, shouldAcceptItemDrop, onReorder, onMove, onDrop]);\n\n  return {\n    collection,\n    selectionManager,\n    isDisabled,\n    target,\n    setTarget(newTarget) {\n      if (this.isDropTarget(newTarget)) {\n        return;\n      }\n\n      let target = targetRef.current;\n      if (target && typeof props.onDropExit === 'function') {\n        props.onDropExit({\n          type: 'dropexit',\n          x: 0, // todo\n          y: 0,\n          target\n        });\n      }\n\n      if (newTarget && typeof onDropEnter === 'function') {\n        onDropEnter({\n          type: 'dropenter',\n          x: 0, // todo\n          y: 0,\n          target: newTarget\n        });\n      }\n\n      targetRef.current = newTarget ?? null;\n      setTarget(newTarget ?? null);\n    },\n    isDropTarget(dropTarget) {\n      let target = targetRef.current;\n      if (!target || !dropTarget) {\n        return false;\n      }\n      if (isEqualDropTarget(dropTarget, target)) {\n        return true;\n      }\n\n      // Check if the targets point at the same point between two items, one referring before, and the other after.\n      if (\n        dropTarget?.type === 'item' &&\n        target?.type === 'item' &&\n        dropTarget.key !== target.key &&\n        dropTarget.dropPosition !== target.dropPosition &&\n        dropTarget.dropPosition !== 'on' &&\n        target.dropPosition !== 'on'\n      ) {\n        return isEqualDropTarget(getOppositeTarget(dropTarget), target) ||\n          isEqualDropTarget(dropTarget, getOppositeTarget(target));\n      }\n\n      return false;\n    },\n    getDropOperation(e) {\n      return defaultGetDropOperation(e);\n    }\n  };\n}\n\nfunction isEqualDropTarget(a?: DropTarget | null, b?: DropTarget | null) {\n  if (!a) {\n    return !b;\n  }\n\n  switch (a.type) {\n    case 'root':\n      return b?.type === 'root';\n    case 'item':\n      return b?.type === 'item' && b?.key === a.key && b?.dropPosition === a.dropPosition;\n  }\n}\n\nfunction isDraggingWithinParent(collection: Collection<Node<unknown>>, target: ItemDropTarget, draggingKeys: Set<Key>) {\n  let targetNode = collection.getItem(target.key);\n\n  for (let key of draggingKeys) {\n    let node = collection.getItem(key);\n    if (node?.parentKey !== targetNode?.parentKey) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"],"names":[],"version":3,"file":"useDroppableCollectionState.module.js.map"}