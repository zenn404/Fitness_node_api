{"mappings":";;;;;;;;AAAA;;;;;;;;;;CAUC;AA+CM,SAAS,0CAAwC,KAAyC;IAC/F,IAAI,YACF,QAAQ,cACR,UAAU,cACV,UAAU,oBACV,gBAAgB,eAChB,WAAW,cACX,UAAU,aACV,SAAS,WACT,OAAO,4BACP,wBAAwB,EACzB,GAAG;IACJ,IAAI,GAAG,YAAY,GAAG,CAAA,GAAA,qBAAO,EAAE;IAC/B,IAAI,eAAe,CAAA,GAAA,mBAAK,EAAE,IAAI;IAC9B,IAAI,aAAa,CAAA,GAAA,mBAAK,EAAc;IACpC,IAAI,UAAU,CAAC;QACb,mFAAmF;QACnF,sFAAsF;QACtF,uDAAuD;QACvD,2FAA2F;QAC3F,IAAI,OAAO,IAAI;QACf,IAAI,iBAAiB,UAAU,CAAC,MAC9B,KAAK,IAAI,cAAc,iBAAiB,YAAY,CAAE;YACpD,IAAI,OAAO,WAAW,OAAO,CAAC;YAC9B,IAAI,MAAM;gBACR,IAAI,UAAU;gBACd,IAAI,YAAY,KAAK,SAAS;gBAC9B,MAAO,aAAa,KAAM;oBACxB,qCAAqC;oBACrC,IAAI,iBAAiB,YAAY,CAAC,GAAG,CAAC,YAAY;wBAChD,UAAU;wBACV;oBACF;oBACA,IAAI,aAAa,WAAW,OAAO,CAAC;oBACpC,YAAY,aAAa,WAAW,SAAS,GAAG;gBAClD;gBAEA,IAAI,CAAC,SACH,KAAK,GAAG,CAAC;YAEb;QACF;aAEA,KAAK,GAAG,CAAC;QAGX,OAAO;IACT;IAEA,OAAO;oBACL;0BACA;QACA,IAAI,cAAa;YACf,OAAO,WAAW,OAAO;QAC3B;QACA,IAAI,gBAAe;YACjB,OAAO,aAAa,OAAO;QAC7B;QACA,YAAW,GAAG;YACZ,OAAO,aAAa,OAAO,CAAC,GAAG,CAAC;QAClC;QACA,gBAAgB;QAChB,UAAS,GAAG;YACV,IAAI,OAAO,QAAQ;YACnB,IAAI,QAAe,EAAE;YACrB,KAAK,IAAI,OAAO,KAAM;oBACR;gBAAZ,IAAI,SAAQ,sBAAA,WAAW,OAAO,CAAC,kBAAnB,0CAAA,oBAAyB,KAAK;gBAC1C,IAAI,SAAS,MACX,MAAM,IAAI,CAAC;YAEf;YAEA,OAAO,SAAS,QAAQ,MAAM;QAChC;oBACA;iBACA;kCACA;QACA,WAAU,GAAG,EAAE,KAAK;YAClB,IAAI,OAAO,QAAQ;YACnB,aAAa,OAAO,GAAG;YACvB,WAAW,OAAO,GAAG;YACrB,iBAAiB,UAAU,CAAC;YAC5B,YAAY;YACZ,IAAI,OAAO,gBAAgB,YACzB,YAAY;gBACV,GAAG,KAAK;sBACR;YACF;QAEJ;QACA,UAAS,KAAK;YACZ,IAAI,OAAO,eAAe,YACxB,WAAW;gBACT,GAAG,KAAK;gBACR,MAAM,aAAa,OAAO;YAC5B;QAEJ;QACA,SAAQ,KAAK;YACX,IAAI,cACF,UAAU,EACX,GAAG;YAEJ,IAAI,OAAO,cAAc,YACvB,UAAU;gBACR,GAAG,KAAK;gBACR,MAAM,aAAa,OAAO;4BAC1B;YACF;YAGF,aAAa,OAAO,GAAG,IAAI;YAC3B,WAAW,OAAO,GAAG;YACrB,YAAY;QACd;IACF;AACF","sources":["packages/@react-stately/dnd/src/useDraggableCollectionState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DraggableCollectionEndEvent, DraggableCollectionProps, DragItem, DragMoveEvent, DragPreviewRenderer, DragStartEvent, DropOperation, Key, Node, RefObject} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useRef, useState} from 'react';\n\nexport interface DraggableCollectionStateOptions<T = object> extends DraggableCollectionProps<T> {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** Whether the drag events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface DraggableCollectionState {\n  /** A collection of items. */\n  collection: Collection<Node<unknown>>,\n  /** An interface for reading and updating multiple selection state. */\n  selectionManager: MultipleSelectionManager,\n  /** The key of the item that initiated a drag. */\n  draggedKey: Key | null,\n  /** The keys of the items that are currently being dragged. */\n  draggingKeys: Set<Key>,\n  /** Whether drag events are disabled. */\n  isDisabled?: boolean,\n  /** Returns whether the given key is currently being dragged. */\n  isDragging(key: Key): boolean,\n  /** Returns the keys of the items that will be dragged with the given key (e.g. selected items). */\n  getKeysForDrag(key: Key): Set<Key>,\n  /** Returns the items to drag for the given key. */\n  getItems(key: Key): DragItem[],\n  /** The ref of the element that will be rendered as the drag preview while dragging. */\n  preview?: RefObject<DragPreviewRenderer | null>,\n  /** Function that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed. */\n  getAllowedDropOperations?: () => DropOperation[],\n  /** Begins a drag for the given key. This triggers the onDragStart event. */\n  startDrag(key: Key, event: DragStartEvent): void,\n  /** Triggers an onDragMove event. */\n  moveDrag(event: DragMoveEvent): void,\n  /** Ends the current drag, and emits an onDragEnd event. */\n  endDrag(event: DraggableCollectionEndEvent): void\n}\n\n/**\n * Manages state for a draggable collection.\n */\nexport function useDraggableCollectionState<T = object>(props: DraggableCollectionStateOptions<T>): DraggableCollectionState {\n  let {\n    getItems,\n    isDisabled,\n    collection,\n    selectionManager,\n    onDragStart,\n    onDragMove,\n    onDragEnd,\n    preview,\n    getAllowedDropOperations\n  } = props;\n  let [, setDragging] = useState(false);\n  let draggingKeys = useRef(new Set<Key>());\n  let draggedKey = useRef<Key | null>(null);\n  let getKeys = (key: Key) => {\n    // The clicked item is always added to the drag. If it is selected, then all of the\n    // other selected items are also dragged. If it is not selected, then only the clicked\n    // item is dragged. This matches native macOS behavior.\n    // Additionally, we filter out any keys that are children of any of the other selected keys\n    let keys = new Set<Key>();\n    if (selectionManager.isSelected(key)) {\n      for (let currentKey of selectionManager.selectedKeys) {\n        let node = collection.getItem(currentKey);\n        if (node) {\n          let isChild = false;\n          let parentKey = node.parentKey;\n          while (parentKey != null) {\n            // eslint-disable-next-line max-depth\n            if (selectionManager.selectedKeys.has(parentKey)) {\n              isChild = true;\n              break;\n            }\n            let parentNode = collection.getItem(parentKey);\n            parentKey = parentNode ? parentNode.parentKey : null;\n          }\n\n          if (!isChild) {\n            keys.add(currentKey);\n          }\n        }\n      }\n    } else {\n      keys.add(key);\n    }\n\n    return keys;\n  };\n\n  return {\n    collection,\n    selectionManager,\n    get draggedKey() {\n      return draggedKey.current;\n    },\n    get draggingKeys() {\n      return draggingKeys.current;\n    },\n    isDragging(key) {\n      return draggingKeys.current.has(key);\n    },\n    getKeysForDrag: getKeys,\n    getItems(key) {\n      let keys = getKeys(key);\n      let items: any[] = [];\n      for (let key of keys) {\n        let value = collection.getItem(key)?.value;\n        if (value != null) {\n          items.push(value);\n        }\n      }\n\n      return getItems(getKeys(key), items);\n    },\n    isDisabled,\n    preview,\n    getAllowedDropOperations,\n    startDrag(key, event) {\n      let keys = getKeys(key);\n      draggingKeys.current = keys;\n      draggedKey.current = key;\n      selectionManager.setFocused(false);\n      setDragging(true);\n      if (typeof onDragStart === 'function') {\n        onDragStart({\n          ...event,\n          keys\n        });\n      }\n    },\n    moveDrag(event) {\n      if (typeof onDragMove === 'function') {\n        onDragMove({\n          ...event,\n          keys: draggingKeys.current\n        });\n      }\n    },\n    endDrag(event) {\n      let {\n        isInternal\n      } = event;\n\n      if (typeof onDragEnd === 'function') {\n        onDragEnd({\n          ...event,\n          keys: draggingKeys.current,\n          isInternal\n        });\n      }\n\n      draggingKeys.current = new Set();\n      draggedKey.current = null;\n      setDragging(false);\n    }\n  };\n}\n"],"names":[],"version":3,"file":"useDraggableCollectionState.main.js.map"}